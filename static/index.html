<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>üèè Cricket Fitness Tracker</title>
    <meta name="description" content="Voice-powered cricket fitness tracking for young athletes">
    <meta name="theme-color" content="#4f46e5">
    
    <!-- PWA Meta Tags -->
    <link rel="manifest" href="/static/manifest.json">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Cricket Tracker">
    
    <!-- Mobile-First Styles -->
    <link rel="stylesheet" href="/static/css/mobile-first.css">
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header class="header">
            <h1>üèè Cricket Fitness Tracker</h1>
            <p>Voice-powered tracking for young athletes</p>
        </header>

        <!-- Navigation -->
        <nav class="nav-tabs">
            <button class="nav-tab active" data-tab="dashboard">üè† Dashboard</button>
            <button class="nav-tab" data-tab="analytics">üìä Analytics</button>
            <button class="nav-tab" data-tab="entries">üìã Entries</button>
            <button class="nav-tab" data-tab="chat">ü§ñ AI Coach</button>
        </nav>

        <!-- Dashboard Tab -->
        <div id="dashboard-tab" class="tab-content active">
            <!-- Activity Logging Cards -->
            <section class="card">
                <h2>üìù Log Today's Activities</h2>
                <p style="color: var(--text-secondary); margin-bottom: var(--spacing-lg);">
                    Tap an activity to start voice logging
                </p>
                
                <div id="activity-grid" class="activity-grid">
                    <!-- Activity cards will be populated by JavaScript -->
                    <div class="activity-card" data-activity="fitness">
                        <div class="icon">üèÉ</div>
                        <div class="title">Fitness</div>
                        <div class="status">Tap to log</div>
                    </div>
                    <div class="activity-card" data-activity="cricket_coaching">
                        <div class="icon">üèè</div>
                        <div class="title">Cricket</div>
                        <div class="status">Tap to log</div>
                    </div>
                    <div class="activity-card" data-activity="cricket_match">
                        <div class="icon">üèÜ</div>
                        <div class="title">Match</div>
                        <div class="status">Tap to log</div>
                    </div>
                    <div class="activity-card" data-activity="rest_day">
                        <div class="icon">üò¥</div>
                        <div class="title">Rest Day</div>
                        <div class="status">Tap to log</div>
                    </div>
                </div>
            </section>

            <!-- Quick Stats -->
            <section class="card">
                <h2>üìä Quick Stats</h2>
                <div id="quick-stats" class="quick-stats">
                    <!-- Stats will be populated by JavaScript -->
                    <div class="stat-item">
                        <span class="stat-value">-</span>
                        <div class="stat-label">This period</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value">-</span>
                        <div class="stat-label">Weekly goal</div>
                    </div>
                </div>
            </section>

            <!-- Progress Indicators -->
            <section class="card">
                <div id="progress-section" class="progress-section">
                    <h3>üìà This Week's Progress</h3>
                    
                    <div class="progress-item">
                        <div class="progress-text">
                            <span>Fitness Sessions</span>
                            <span id="fitness-progress-text">-/7 days</span>
                        </div>
                        <div class="progress-bar">
                            <div id="fitness-progress-fill" class="progress-fill" style="width: 0%"></div>
                        </div>
                    </div>

                    <div class="progress-item">
                        <div class="progress-text">
                            <span>Cricket Practice</span>
                            <span id="cricket-progress-text">-/5 sessions</span>
                        </div>
                        <div class="progress-bar">
                            <div id="cricket-progress-fill" class="progress-fill" style="width: 0%"></div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Recent Activity -->
            <section class="card">
                <div id="recent-activity">
                    <h3>üìã Recent Activity</h3>
                    <div class="empty-state">
                        <p>Loading recent activities...</p>
                    </div>
                </div>
            </section>

            <!-- Refresh Button -->
            <button id="refresh-dashboard" class="btn full-width" style="margin-top: var(--spacing-lg);">
                üîÑ Refresh Dashboard
            </button>
        </div>

        <!-- Analytics Tab -->
        <div id="analytics-tab" class="tab-content hidden">
            <section class="card">
                <h2>üìä Performance Analytics</h2>
                <p style="color: var(--text-secondary); margin-bottom: var(--spacing-lg);">
                    Visualize your cricket and fitness progress with interactive charts
                </p>
                
                <!-- Analytics Type Selector -->
                <div style="display: flex; gap: var(--spacing-sm); margin-bottom: var(--spacing-lg); flex-wrap: wrap;">
                    <button class="btn" onclick="loadFitnessCharts()" style="flex: 1; min-width: 120px;">
                        üèÉ Fitness Charts
                    </button>
                    <button class="btn" onclick="loadCricketCharts()" style="flex: 1; min-width: 120px;">
                        üèè Cricket Charts
                    </button>
                    <button class="btn" onclick="loadCombinedCharts()" style="flex: 1; min-width: 120px;">
                        üîÑ Combined View
                    </button>
                </div>
                
                <!-- Loading Indicator for Charts -->
                <div id="charts-loading" class="hidden" style="text-align: center; padding: var(--spacing-xl);">
                    <div class="loading"></div>
                    <p style="margin-top: var(--spacing-md); color: var(--text-secondary);">
                        Loading analytics charts...
                    </p>
                </div>
                
                <!-- Charts will be dynamically inserted here -->
            </section>
        </div>

        <!-- Entries Tab -->
        <div id="entries-tab" class="tab-content hidden">
            <section class="card">
                <h2>üìã Your Activity Log</h2>
                <p style="color: var(--text-secondary); margin-bottom: var(--spacing-lg);">
                    Browse through your logged activities with beautiful, user-friendly cards
                </p>
                
                <!-- Entry Statistics -->
                <div id="entry-stats" class="hidden" style="margin-bottom: var(--spacing-lg);">
                    <div class="stat-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: var(--spacing-sm);">
                        <div class="stat-card">
                            <div class="stat-number" id="total-entries">0</div>
                            <div class="stat-label">Total</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number" id="fitness-count">0</div>
                            <div class="stat-label">üèÉ Fitness</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number" id="cricket-count">0</div>
                            <div class="stat-label">üèè Cricket</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number" id="match-count">0</div>
                            <div class="stat-label">üèÜ Matches</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number" id="rest-count">0</div>
                            <div class="stat-label">üò¥ Rest</div>
                        </div>
                    </div>
                </div>
                
                <!-- Entry Search -->
                <div class="entry-search">
                    <input type="text" id="entry-search-input" placeholder="Search your activities..." autocomplete="off">
                </div>
                
                <!-- Activity Type Filter -->
                <div class="entry-filters" style="margin-bottom: var(--spacing-lg);">
                    <button class="filter-btn active" data-filter="all">üìä All Activities</button>
                    <button class="filter-btn" data-filter="fitness">üèÉ Fitness</button>
                    <button class="filter-btn" data-filter="cricket_coaching">üèè Cricket Practice</button>
                    <button class="filter-btn" data-filter="cricket_match">üèÜ Matches</button>
                    <button class="filter-btn" data-filter="rest_day">üò¥ Rest Days</button>
                </div>
                
                <!-- Entries Container -->
                <div id="entries-container">
                    <div class="entries-loading">
                        <div class="loading"></div>
                        <p>Loading your activities...</p>
                    </div>
                </div>
                
                <!-- Load More Button -->
                <div id="load-more-container" class="hidden" style="text-align: center; margin-top: var(--spacing-lg);">
                    <button id="load-more-btn" class="btn secondary">üì• Load More Entries</button>
                </div>
            </section>
        </div>

        <!-- Chat Tab -->
        <div id="chat-tab" class="tab-content hidden">
            <section class="card">
                <h2>ü§ñ AI Cricket Coach</h2>
                <p style="color: var(--text-secondary); margin-bottom: var(--spacing-lg);">
                    Get personalized insights and cricket advice
                </p>
                
                <div id="chat-interface" style="min-height: 300px; display: flex; align-items: center; justify-content: center;">
                    <div style="text-align: center; color: var(--text-secondary);">
                        <div style="font-size: 3rem; margin-bottom: var(--spacing-md);">ü§ñ</div>
                        <p>AI Chat Interface</p>
                        <p style="font-size: 0.9rem; margin-top: var(--spacing-sm);">
                            Coming soon! Your cricket coach powered by AI.
                        </p>
                    </div>
                </div>
            </section>
        </div>

        <!-- Loading Indicator -->
        <div id="loading-indicator" class="hidden" style="text-align: center; padding: var(--spacing-lg);">
            <div class="loading"></div>
            <span>Loading...</span>
        </div>

        <!-- Error Message -->
        <div id="error-message" class="hidden status error" style="margin: var(--spacing-lg) 0;">
            Error message will appear here
        </div>
    </div>

    <!-- Voice Recording Modal -->
    <div id="voice-modal" class="voice-modal hidden">
        <div class="voice-content">
            <div class="voice-header">
                <h3 id="voice-title">üé§ Voice Recording</h3>
                <button class="close-btn" onclick="closeVoiceModal()">√ó</button>
            </div>
            
            <div class="voice-instructions">
                <p id="voice-description" style="color: var(--text-secondary); margin-bottom: var(--spacing-lg);">
                    Speak naturally about your activity
                </p>
                <div class="instruction-tips">
                    <div class="tip-item">üí° <span>Be specific about duration, intensity, and how you felt</span></div>
                    <div class="tip-item">üéØ <span>Mention key details like distance, skills practiced, or performance</span></div>
                </div>
            </div>
            
            <div class="recording-section">
                <div class="record-button-container">
                    <button id="record-btn" class="record-btn enhanced">
                        <span class="btn-icon">üé§</span>
                        <span class="btn-text">Start Recording</span>
                    </button>
                    <div class="record-instruction">Tap to start recording</div>
                </div>
                
                <div id="recording-visualizer" class="recording-visualizer hidden">
                    <div class="visualizer-bars">
                        <div class="recording-bar"></div>
                        <div class="recording-bar"></div>
                        <div class="recording-bar"></div>
                        <div class="recording-bar"></div>
                        <div class="recording-bar"></div>
                    </div>
                    <div class="recording-text">Recording in progress...</div>
                </div>
            </div>
            
            <div id="status-message" class="status info enhanced">
                <span class="status-icon">‚ÑπÔ∏è</span>
                <span class="status-text">Click the microphone to start recording</span>
            </div>
            
            <div id="transcript-display" class="hidden transcript-container">
                <div class="transcript-header">
                    <strong>üìù What you said:</strong>
                </div>
                <p id="transcript-text" class="transcript-text"></p>
            </div>
            
            <div id="processed-data" class="hidden processed-data-container">
                <div class="processed-header">
                    <strong>üìä Processed Data:</strong>
                </div>
                <pre id="processed-data-content" class="processed-content"></pre>
            </div>
            
            <div class="voice-actions">
                <button class="btn secondary" onclick="closeVoiceModal()">
                    <span>Cancel</span>
                </button>
                <button class="btn primary" onclick="closeVoiceModal()" id="done-btn" style="display: none;">
                    <span>‚úÖ Done</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Chart.js for Analytics -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
    
    <!-- Scripts -->
    <script src="/static/js/dashboard.js"></script>
    <script src="/static/js/charts.js"></script>
    <script>
        // Initialize all global variables immediately to prevent hoisting issues
        (function() {
            'use strict';
            
            // Global variables for voice interface integration - Initialize with explicit values
            window.currentEntryType = 'fitness';
            window.socket = null;
            window.isRecording = false;
            window.mediaRecorder = null;
            window.audioStream = null;
            window.currentSessionId = crypto.randomUUID();
            // Turn counter for conversation flow visualization - Use window object to ensure global scope
            window.flowTurn = 0;
            // Flag to prevent multiple conversation creations
            window.isCreatingConversation = false;
            
            // Also set them as var declarations for compatibility
            var currentEntryType = window.currentEntryType;
            var socket = window.socket;
            var isRecording = window.isRecording;
            var mediaRecorder = window.mediaRecorder;
            var audioStream = window.audioStream;
            var currentSessionId = window.currentSessionId;
            var flowTurn = window.flowTurn;
            var isCreatingConversation = window.isCreatingConversation;
        })();

        // Helper function to map entry types to ActivityType enum values
        function mapEntryTypeToActivityType(entryType) {
            const mapping = {
                'fitness': 'FITNESS',
                'cricket_coaching': 'CRICKET_COACHING',
                'cricket_match': 'CRICKET_MATCH',
                'rest_day': 'REST_DAY'
            };
            return mapping[entryType] || 'FITNESS';
        }

        // Function to create a new conversation
        async function createConversation() {
            const token = localStorage.getItem("token");
            const activityType = mapEntryTypeToActivityType(window.currentEntryType);
            
            try {
                console.log(`üì§ Creating conversation for activity type: ${activityType}`);
                const response = await fetch('/api/conversations', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`,
                    },
                    body: JSON.stringify({
                        activity_type: activityType,
                        chat_messages: []
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Failed to create conversation: ${response.status} - ${errorText}`);
                }

                const conversation = await response.json();
                console.log('‚úÖ Conversation created:', conversation);
                return conversation;
            } catch (error) {
                console.error('‚ùå Failed to create conversation:', error);
                throw error;
            }
        }

        // Voice modal functions
        // Voice modal functions
        async function openVoiceModal(entryType) {
            // Initialize global flag if undefined
            if (typeof window.isCreatingConversation === 'undefined') {
                window.isCreatingConversation = false;
            }

            // Prevent multiple simultaneous calls
            if (window.isCreatingConversation) {
                console.log('‚ö†Ô∏è Conversation creation already in progress, skipping...');
                return;
            }

            window.isCreatingConversation = true;

            try {
                window.currentEntryType = entryType;
                const modal = document.getElementById('voice-modal');
                const title = document.getElementById('voice-title');
                const description = document.getElementById('voice-description');

                const titles = {
                    'fitness': 'üèÉ Log Fitness Activity',
                    'cricket_coaching': 'üèè Log Cricket Practice',
                    'cricket_match': 'üèÜ Log Match Performance',
                    'rest_day': 'üò¥ Log Rest Day'
                };

                const descriptions = {
                    'fitness': 'Tell me about your workout, running, or fitness activity',
                    'cricket_coaching': 'Describe your cricket practice session and what you worked on',
                    'cricket_match': 'Share details about your match performance and how it went',
                    'rest_day': 'Let me know how your rest day went and how you\'re feeling'
                };

                title.textContent = titles[entryType] || 'üé§ Voice Recording';
                description.textContent = descriptions[entryType] || 'Speak naturally about your activity';

                // Reset conversation state for new activity type
                resetConversationState();

                modal.classList.remove('hidden');

                // Connect WebSocket if not already connected
                if (!window.socket || window.socket.readyState !== WebSocket.OPEN) {
                    console.log('üîÑ Creating new conversation...');
                    updateStatus('üîÑ Creating conversation session...', 'info');

                    const conversation = await createConversation();
                    if (!conversation || !conversation.id) {
                        console.error('‚ùå Conversation creation failed or returned null:', conversation);
                        updateStatus('‚ùå Failed to create conversation. Please try again.', 'error');
                        modal.classList.add('hidden');
                        return;
                    }

                    window.currentSessionId = conversation.id;
                    
                    // Wait for WebSocket connection before proceeding
                    await new Promise((resolve, reject) => {
                        connectWebSocket(window.currentSessionId);
                        
                        // Set a timeout to avoid hanging indefinitely
                        const timeout = setTimeout(() => {
                            reject(new Error('WebSocket connection timeout'));
                        }, 10000);
                        
                        const checkConnection = setInterval(() => {
                            if (window.socket && window.socket.readyState === WebSocket.OPEN) {
                                clearTimeout(timeout);
                                clearInterval(checkConnection);
                                resolve();
                            }
                        }, 100);
                    });

                    console.log('‚úÖ Conversation created successfully:', window.currentSessionId);
                    updateStatus('‚úÖ Ready to record! Click microphone to start', 'success');
                } else {
                    // WebSocket already connected, just update status
                    updateStatus('‚úÖ Ready to record! Click microphone to start', 'success');
                }

                // Send metadata immediately to prepare backend for new activity type
                setTimeout(() => {
                    sendSessionMetadata();
                }, 500);

            } catch (error) {
                console.error('‚ùå Failed to create conversation:', error);
                const modal = document.getElementById('voice-modal');
                modal.classList.add('hidden');
                updateStatus('‚ùå Failed to start voice logging. Please try again.', 'error');
                
                // Show a more user-friendly error message
                if (error.message.includes('timeout')) {
                    alert('Connection timeout. Please check your internet connection and try again.');
                } else {
                    alert(`Failed to start voice logging: ${error.message}`);
                }
            } finally {
                window.isCreatingConversation = false;
            }
        }

        /**
         * Send session metadata to backend to prepare for new activity type
         */
        function sendSessionMetadata() {
            if (window.socket && window.socket.readyState === WebSocket.OPEN) {
                console.log(`üì§ Sending session metadata for activity type: ${window.currentEntryType}`);
                window.socket.send(JSON.stringify({
                    type: 'voice_data_meta',
                    entry_type: window.currentEntryType
                }));
            } else {
                console.warn('‚ö†Ô∏è WebSocket not ready, will send metadata when recording starts');
            }
        }

        function closeVoiceModal() {
            const modal = document.getElementById('voice-modal');
            modal.classList.add('hidden');
            
            // Stop recording if active
            if (window.isRecording) {
                stopRecording();
            }
            
            // Reset UI
            resetVoiceUI();
        }

        /**
         * Reset conversation state when switching activity types or opening modal
         */
        function resetConversationState() {
            console.log('üîÑ Resetting conversation state for new activity type');
            
            // Reset conversation turn counter - ensure it's properly initialized
            window.flowTurn = 0;
            flowTurn = 0;
            
            // Clear conversation flow UI if it exists
            const flowContainer = document.getElementById('conversation-flow');
            if (flowContainer) {
                flowContainer.remove();
            }
            
            // Clear any existing transcript display
            const transcriptDisplay = document.getElementById('transcript-display');
            if (transcriptDisplay) {
                transcriptDisplay.classList.add('hidden');
                transcriptDisplay.innerHTML = '';
            }
            
            // Clear processed data display
            const processedData = document.getElementById('processed-data');
            if (processedData) {
                processedData.classList.add('hidden');
                processedData.innerHTML = '';
            }
            
            // Clear collected data display if it exists
            const collectedDataEl = document.getElementById('collected-data-display');
            if (collectedDataEl) {
                collectedDataEl.classList.add('hidden');
                collectedDataEl.innerHTML = '';
            }
            
            // Reset status message to initial state
            updateStatus('Click the microphone to start recording', 'info');
            
            // Reset recording UI state
            resetVoiceUI();
            
            console.log('‚úÖ Conversation state reset complete');
        }

        function resetVoiceUI() {
            const statusMessage = document.getElementById('status-message');
            const transcriptDisplay = document.getElementById('transcript-display');
            const processedData = document.getElementById('processed-data');
            const recordBtn = document.getElementById('record-btn');
            const doneBtn = document.getElementById('done-btn');
            
            if (statusMessage) {
                statusMessage.textContent = 'Click the microphone to start recording';
                statusMessage.className = 'status info';
            }
            
            if (transcriptDisplay) {
                transcriptDisplay.classList.add('hidden');
            }
            
            if (processedData) {
                processedData.classList.add('hidden');
            }
            
            if (recordBtn) {
                recordBtn.classList.remove('recording');
                const btnIcon = recordBtn.querySelector('.btn-icon');
                const btnText = recordBtn.querySelector('.btn-text');
                if (btnIcon) btnIcon.textContent = 'üé§';
                if (btnText) btnText.textContent = 'Start Recording';
            }
            
            if (doneBtn) {
                doneBtn.style.display = 'none';
            }
        }

        function connectWebSocket(sessionId) {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const token = localStorage.getItem("token");
            
            if (!token) {
                console.error('‚ùå No authentication token found in localStorage');
                updateStatus('‚ùå Authentication token missing. Please log in again.', 'error');
                return;
            }
            
            const wsUrl = `${protocol}//${window.location.host}/api/voice_ws/ws/${sessionId}?token=${encodeURIComponent(token)}`;

            window.socket = new WebSocket(wsUrl);
            
            window.socket.onopen = function() {
                updateStatus('Connected! Ready to record', 'success');
            };
            
            window.socket.onmessage = function(event) {
                const data = JSON.parse(event.data);
                handleWebSocketMessage(data);
            };
            
            window.socket.onclose = function(event) {
                if (event.code === 4001) {
                    updateStatus('‚ùå Authentication failed. Please check your login.', 'error');
                    console.error('WebSocket closed due to authentication failure');
                } else {
                    updateStatus('Connection closed', 'info');
                    console.log('WebSocket closed with code:', event.code, 'reason:', event.reason);
                }
            };
            
            window.socket.onerror = function(error) {
                updateStatus('‚ùå Connection error. Please try again.', 'error');
                console.error('WebSocket error:', error);
            };
        }

        function handleWebSocketMessage(data) {
            console.log('WebSocket message:', data);
            
            switch(data.type) {
                case 'connection_established':
                    updateStatus('Connected! Click microphone to record', 'success');
                    break;
                    
                case 'voice_meta_received':
                    const activityType = data.data?.entry_type || 'activity';
                    const formattedType = activityType.replace('_', ' ');
                    updateStatus(`Ready to record ${formattedType} session...`, 'info');
                    console.log(`‚úÖ Backend ready for ${activityType} logging`);
                    break;
                    
                case 'audio_chunk_received':
                    updateStatus(`Recording... (${data.data.total_accumulated} bytes)`, 'info');
                    updateRecordingVisualization(true);
                    break;
                    
                case 'transcript_ready': // legacy name
                case 'transcription_completed':
                    // Display transcript in modal
                    showTranscript(data.data.transcript);

                    // Add to conversation flow - ensure flowTurn is properly initialized
                    if (typeof flowTurn === 'undefined') {
                        flowTurn = 0;
                        window.flowTurn = 0;
                    }
                    flowTurn += 1;
                    window.flowTurn = flowTurn;
                    addConversationTurn(flowTurn, data.data.transcript, 'answer');

                    updateStatus('Processing data...', 'info');
                    break;
                    
                case 'conversation_started':
                    updateStatus(`‚úÖ ${data.data.message}`, 'success');
                    break;
                    
                case 'follow_up_question':
                    handleFollowUpQuestion(data.data);
                    break;
                    
                case 'conversation_completed':
                    handleConversationCompleted(data.data);
                    break;
                    
                case 'voice_processed_complete':
                    // Legacy support for single-turn processing
                    showProcessedData(data.data);
                    updateStatus(`‚úÖ Entry saved! ID: ${data.data.saved_entry_id}`, 'success');
                    
                    // Refresh dashboard after successful entry
                    setTimeout(() => {
                        if (window.mobileDashboard) {
                            window.mobileDashboard.loadDashboardData();
                        }
                    }, 1500);
                    break;
                    
                case 'error':
                    updateStatus(`‚ùå Error: ${data.message}`, 'error');
                    break;
            }
        }

        function handleFollowUpQuestion(questionData) {
            console.log('Follow-up question received:', questionData);
            
            // Create conversation flow visualization
            addConversationTurn(questionData.turn_number, questionData.question, 'question');
            
            // Update status with question
            updateStatus(`‚ùì Follow-up Question ${questionData.turn_number}`, 'info');
            
            // Show the question prominently in the UI with enhanced styling
            const statusEl = document.getElementById('status-message');
            
            // Format field targets for display
            const fieldTargets = questionData.field_targets || [];
            const fieldDisplay = fieldTargets.length > 0 
                ? fieldTargets.map(field => field.replace('_', ' ')).join(', ')
                : 'additional information';
            
            statusEl.innerHTML = `
                <div class="conversation-question">
                    <div class="question-header">
                        <span class="question-icon">ü§ñ</span>
                        <strong>Follow-up Question ${questionData.turn_number}</strong>
                        <span class="progress-badge">${Math.round(questionData.completeness_score * 100)}% complete</span>
                        <span class="question-type-badge">${questionData.is_rule_based ? 'Rule-based' : 'AI-generated'}</span>
                    </div>
                    <div class="question-text">"${questionData.question}"</div>
                    <div class="question-footer">
                        <span class="collecting-field">Collecting: ${fieldDisplay}</span>
                        <span class="field-count">${fieldTargets.length} field${fieldTargets.length !== 1 ? 's' : ''}</span>
                    </div>
                </div>
            `;
            statusEl.className = 'status info conversation-status';
            
            // Show collected data so far with enhanced visualization
            if (questionData.collected_data && Object.keys(questionData.collected_data).length > 0) {
                showCollectedData(questionData.collected_data, questionData.turn_number);
            }
            
            // Enable recording for the next response with visual feedback
            const recordBtn = document.getElementById('record-btn');
            recordBtn.disabled = false;
            recordBtn.classList.remove('recording');
            recordBtn.textContent = 'üé§';
            
            // Add pulsing effect to encourage response
            recordBtn.classList.add('ready-to-record');
            setTimeout(() => {
                recordBtn.classList.remove('ready-to-record');
            }, 3000);
            
            // Auto-scroll to keep question visible
            const modal = document.getElementById('voice-modal');
            modal.scrollTop = modal.scrollHeight;
        }

        function handleConversationCompleted(completionData) {
            console.log('Conversation completed:', completionData);
            
            // Add final turn to conversation flow
            addConversationTurn(completionData.total_turns, '‚úÖ Conversation Complete!', 'completion');
            
            // Show celebration animation
            showCompletionCelebration();
            
            // Show completion message with enhanced styling
            updateStatus(`üéâ Success!`, 'success');
            
            // Show final structured data with beautiful formatting
            showProcessedData(completionData);
            
            // Show comprehensive completion summary
            const statusEl = document.getElementById('status-message');
            statusEl.innerHTML = `
                <div class="completion-summary">
                    <div class="completion-header">
                        <span class="completion-icon">üéâ</span>
                        <strong>Activity Logged Successfully!</strong>
                    </div>
                    <div class="completion-message">${completionData.message}</div>
                    <div class="completion-metrics">
                        <div class="metric-card">
                            <span class="metric-value">${completionData.total_turns}</span>
                            <span class="metric-label">Turns</span>
                        </div>
                        <div class="metric-card">
                            <span class="metric-value">${Math.round(completionData.data_quality_score * 100)}%</span>
                            <span class="metric-label">Quality</span>
                        </div>
                        <div class="metric-card">
                            <span class="metric-value">${Math.round(completionData.conversation_efficiency * 100)}%</span>
                            <span class="metric-label">Efficiency</span>
                        </div>
                    </div>
                    <div class="completion-footer">
                        <span class="entry-id">Entry ID: ${completionData.saved_entry_id}</span>
                    </div>
                </div>
            `;
            statusEl.className = 'status success completion-status';
            
            // Disable recording button with success state
            const recordBtn = document.getElementById('record-btn');
            recordBtn.disabled = true;
            recordBtn.textContent = '‚úÖ';
            recordBtn.classList.add('completed');
            
            // Refresh dashboard after successful completion
            setTimeout(() => {
                if (window.mobileDashboard) {
                    window.mobileDashboard.loadDashboardData();
                }
            }, 2000);
            
            // Auto-close modal after 8 seconds with countdown
            showAutoCloseCountdown(8);
        }

        function addConversationTurn(turnNumber, content, type) {
            let flowContainer = document.getElementById('conversation-flow');
            if (!flowContainer) {
                // Create conversation flow container if it doesn't exist
                flowContainer = document.createElement('div');
                flowContainer.id = 'conversation-flow';
                flowContainer.className = 'conversation-flow';
                
                const flowHeader = document.createElement('h4');
                flowHeader.textContent = 'üí¨ Conversation Flow';
                flowHeader.style.marginBottom = 'var(--spacing-md)';
                flowContainer.appendChild(flowHeader);
                
                // Insert after transcript display
                const transcriptEl = document.getElementById('transcript-display');
                transcriptEl.parentNode.insertBefore(flowContainer, transcriptEl.nextSibling);
                
                flowContainer.classList.remove('hidden');
            }
            
            const turnEl = document.createElement('div');
            turnEl.className = 'conversation-turn';
            
            const indicator = document.createElement('div');
            indicator.className = 'turn-indicator';
            indicator.textContent = turnNumber;
            
            const content_el = document.createElement('div');
            content_el.className = 'turn-content';
            
            if (type === 'question') {
                content_el.innerHTML = `<div class="turn-question">${content}</div>`;
                indicator.style.background = 'var(--primary-color)';
            } else if (type === 'answer') {
                content_el.innerHTML = `<div class="turn-answer">${content}</div>`;
                indicator.style.background = 'var(--info-color, #3b82f6)';
            } else if (type === 'completion') {
                content_el.innerHTML = `<div class="turn-completion">${content}</div>`;
                indicator.style.background = 'var(--success-color)';
                indicator.textContent = '‚úì';
            } else {
                content_el.textContent = content;
            }
            
            turnEl.appendChild(indicator);
            turnEl.appendChild(content_el);
            flowContainer.appendChild(turnEl);
            
            // Smooth scroll to new turn
            setTimeout(() => {
                turnEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }, 100);
        }

        function showCollectedData(collectedData, turnNumber) {
            const dataEl = document.getElementById('processed-data');
            if (!dataEl) return;
            
            const fieldsCount = Object.keys(collectedData).length;
            const dataContent = document.getElementById('processed-data-content');
            
            // Format collected data in a more user-friendly way
            const formattedData = Object.entries(collectedData).map(([key, value]) => {
                const label = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                return `${label}: ${value}`;
            }).join('\n');
            
            dataContent.innerHTML = `
                <div class="collected-data-header">
                    <strong>üìä Data Collected So Far (Turn ${turnNumber})</strong>
                    <span class="field-count">${fieldsCount} fields</span>
                </div>
                <div class="collected-data-content">${formattedData}</div>
            `;
            
            dataEl.classList.remove('hidden');
            dataEl.style.borderColor = 'var(--primary-color)';
        }

        function showCompletionCelebration() {
            // Add floating celebration elements
            const modal = document.querySelector('.voice-content');
            for (let i = 0; i < 6; i++) {
                setTimeout(() => {
                    createCelebrationElement(modal);
                }, i * 200);
            }
        }

        function createCelebrationElement(container) {
            const celebration = document.createElement('div');
            celebration.textContent = ['üéâ', '‚ú®', 'üéä', '‚≠ê', 'üí´'][Math.floor(Math.random() * 5)];
            celebration.style.cssText = `
                position: absolute;
                top: ${Math.random() * 20 + 10}%;
                left: ${Math.random() * 80 + 10}%;
                font-size: 1.5rem;
                pointer-events: none;
                z-index: 10;
                animation: celebrationFloat 2s ease-out forwards;
            `;
            
            container.style.position = 'relative';
            container.appendChild(celebration);
            
            setTimeout(() => {
                if (celebration.parentNode) {
                    celebration.parentNode.removeChild(celebration);
                }
            }, 2000);
        }

        function showAutoCloseCountdown(seconds) {
            let timeLeft = seconds;
            const countdownEl = document.createElement('div');
            countdownEl.className = 'auto-close-countdown';
            countdownEl.innerHTML = `
                <div class="countdown-text">Auto-closing in <span id="countdown-number">${timeLeft}</span> seconds</div>
                <button class="btn secondary small" onclick="cancelAutoClose()">Stay Open</button>
            `;
            
            document.querySelector('.voice-content').appendChild(countdownEl);
            
            const countdownInterval = setInterval(() => {
                timeLeft--;
                const numberEl = document.getElementById('countdown-number');
                if (numberEl) {
                    numberEl.textContent = timeLeft;
                }
                
                if (timeLeft <= 0) {
                    clearInterval(countdownInterval);
                    closeVoiceModal();
                }
            }, 1000);
            
            // Store interval ID for potential cancellation
            window.autoCloseInterval = countdownInterval;
        }

        function cancelAutoClose() {
            if (window.autoCloseInterval) {
                clearInterval(window.autoCloseInterval);
                window.autoCloseInterval = null;
            }
            
            const countdownEl = document.querySelector('.auto-close-countdown');
            if (countdownEl) {
                countdownEl.remove();
            }
        }

        function updateRecordingVisualization(isActive) {
            const visualizerEl = document.getElementById('recording-visualizer');
            if (visualizerEl) {
                const bars = visualizerEl.querySelectorAll('.recording-bar');
                bars.forEach(bar => {
                    if (isActive) {
                        bar.classList.add('active');
                    } else {
                        bar.classList.remove('active');
                    }
                });
                
                if (isActive) {
                    visualizerEl.classList.remove('hidden');
                } else {
                    setTimeout(() => {
                        visualizerEl.classList.add('hidden');
                    }, 500);
                }
            }
        }

        function updateStatus(message, type) {
            const statusEl = document.getElementById('status-message');
            const statusIcon = statusEl.querySelector('.status-icon');
            const statusText = statusEl.querySelector('.status-text');
            
            // Update icon based on type
            const icons = {
                'info': '‚ÑπÔ∏è',
                'success': '‚úÖ',
                'error': '‚ùå',
                'warning': '‚ö†Ô∏è'
            };
            
            if (statusIcon) statusIcon.textContent = icons[type] || '‚ÑπÔ∏è';
            if (statusText) statusText.textContent = message;
            statusEl.className = `status ${type} enhanced`;
        }

        function showTranscript(transcript) {
            const transcriptEl = document.getElementById('transcript-display');
            const transcriptText = document.getElementById('transcript-text');
            
            transcriptText.textContent = transcript;
            transcriptEl.classList.remove('hidden');
            
            // Add typing animation effect
            transcriptText.style.opacity = '0';
            transcriptText.style.transform = 'translateY(10px)';
            
            setTimeout(() => {
                transcriptText.style.transition = 'all 0.5s ease';
                transcriptText.style.opacity = '1';
                transcriptText.style.transform = 'translateY(0)';
            }, 100);
        }

        function showProcessedData(data) {
            const processedEl = document.getElementById('processed-data');
            const processedContent = document.getElementById('processed-data-content');
            const doneBtn = document.getElementById('done-btn');
            
            // Format the structured data more beautifully
            let formattedData;
            if (data.structured_data) {
                formattedData = Object.entries(data.structured_data)
                    .map(([key, value]) => {
                        const label = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        return `${label}: ${value}`;
                    })
                    .join('\n');
            } else {
                formattedData = JSON.stringify(data, null, 2);
            }
            
            processedContent.textContent = formattedData;
            processedEl.classList.remove('hidden');
            
            // Show done button
            if (doneBtn) {
                doneBtn.style.display = 'block';
            }
            
            // Add success animation
            processedEl.style.opacity = '0';
            processedEl.style.transform = 'translateY(20px)';
            
            setTimeout(() => {
                processedEl.style.transition = 'all 0.5s ease';
                processedEl.style.opacity = '1';
                processedEl.style.transform = 'translateY(0)';
            }, 100);
        }

        async function toggleRecording() {
            if (!window.isRecording) {
                await startRecording();
            } else {
                stopRecording();
            }
        }

        async function startRecording() {
            try {
                // Update button appearance
                const recordBtn = document.getElementById('record-btn');
                const btnIcon = recordBtn.querySelector('.btn-icon');
                const btnText = recordBtn.querySelector('.btn-text');
                
                recordBtn.classList.add('recording');
                if (btnIcon) btnIcon.textContent = '‚èπÔ∏è';
                if (btnText) btnText.textContent = 'Stop Recording';
                
                // Show recording visualizer
                updateRecordingVisualization(true);
                
                // Ensure backend has current session metadata before recording
                if (window.socket && window.socket.readyState === WebSocket.OPEN) {
                    console.log('üì§ Ensuring backend has current session metadata before recording');
                    window.socket.send(JSON.stringify({
                        type: 'voice_data_meta',
                        entry_type: window.currentEntryType
                    }));
                }

                // Get microphone access
                window.audioStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true
                    } 
                });
                
                window.mediaRecorder = new MediaRecorder(window.audioStream, {
                    mimeType: 'audio/webm;codecs=opus'
                });
                
                window.mediaRecorder.ondataavailable = function(event) {
                    if (event.data.size > 0 && window.socket.readyState === WebSocket.OPEN) {
                        window.socket.send(event.data);
                    }
                };
                
                window.mediaRecorder.onstop = function() {
                    if (window.socket && window.socket.readyState === WebSocket.OPEN) {
                        window.socket.send(JSON.stringify({
                            type: 'recording_complete'
                        }));
                    }
                };
                
                window.mediaRecorder.start(1000);
                window.isRecording = true;
                
                updateStatus('üé§ Recording... speak naturally about your activity', 'info');
                
            } catch (error) {
                console.error('Recording failed:', error);
                updateStatus('Recording failed: ' + error.message, 'error');
                
                // Reset button on error
                const recordBtn = document.getElementById('record-btn');
                const btnIcon = recordBtn.querySelector('.btn-icon');
                const btnText = recordBtn.querySelector('.btn-text');
                
                recordBtn.classList.remove('recording');
                if (btnIcon) btnIcon.textContent = 'üé§';
                if (btnText) btnText.textContent = 'Start Recording';
            }
        }

        function stopRecording() {
            if (window.mediaRecorder && window.isRecording) {
                window.mediaRecorder.stop();
                window.isRecording = false;
                
                // Stop all tracks
                if (window.audioStream) {
                    window.audioStream.getTracks().forEach(track => track.stop());
                }
                
                // Update button appearance
                const recordBtn = document.getElementById('record-btn');
                const btnIcon = recordBtn.querySelector('.btn-icon');
                const btnText = recordBtn.querySelector('.btn-text');
                
                recordBtn.classList.remove('recording');
                if (btnIcon) btnIcon.textContent = 'üé§';
                if (btnText) btnText.textContent = 'Start Recording';
                
                // Hide recording visualizer
                updateRecordingVisualization(false);
                
                updateStatus('üîÑ Processing your audio...', 'info');
            }
        }

        // Analytics Chart Functions
        function showChartsLoading() {
            // Use the chart class loading indicator if available
            if (window.analyticsCharts && typeof window.analyticsCharts.showLoadingIndicator === 'function') {
                window.analyticsCharts.showLoadingIndicator();
            } else {
                // Fallback to global loading indicator
                const loadingEl = document.getElementById('charts-loading');
                if (loadingEl) {
                    loadingEl.classList.remove('hidden');
                }
            }
        }
        
        function hideChartsLoading() {
            // Use the chart class loading indicator if available
            if (window.analyticsCharts && typeof window.analyticsCharts.hideLoadingIndicator === 'function') {
                window.analyticsCharts.hideLoadingIndicator();
            } else {
                // Fallback to global loading indicator
                const loadingEl = document.getElementById('charts-loading');
                if (loadingEl) {
                    loadingEl.classList.add('hidden');
                }
            }
        }

        // API Request Helper Function
        // async function apiRequest(endpoint) {
        //     try {
        //         const response = await fetch(endpoint);
        //         const data = await response.json();
        //         return JSON.stringify(data, null, 2);
        //     } catch (error) {
        //         return `Error: ${error.message}`;
        //     }
        // }
        async function apiRequest(endpoint) {
            const token = localStorage.getItem("token");  // ‚¨ÖÔ∏è get token from localStorage

            try {
                const response = await fetch(endpoint, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`,  // ‚¨ÖÔ∏è send token in header
                    },
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    return `Error ${response.status}: ${errorText}`;
                }

                const data = await response.json();
                return JSON.stringify(data, null, 2);
            } catch (error) {
                return `Error: ${error.message}`;
            }
        }


        async function loadFitnessCharts() {
            const btn = event.target;
            const originalText = btn.innerHTML;
            
            btn.innerHTML = '<span class="loading"></span> Loading...';
            btn.disabled = true;
            
            try {
                if (window.analyticsCharts) {
                    await window.analyticsCharts.renderFitnessAnalytics();
                }
            } catch (error) {
                console.error('Failed to load fitness charts:', error);
            } finally {
                btn.innerHTML = originalText;
                btn.disabled = false;
            }
        }

        async function loadCricketCharts() {
            const btn = event.target;
            const originalText = btn.innerHTML;
            
            btn.innerHTML = '<span class="loading"></span> Loading...';
            btn.disabled = true;
            
            try {
                if (window.analyticsCharts) {
                    await window.analyticsCharts.renderCricketAnalytics();
                }
            } catch (error) {
                console.error('Failed to load cricket charts:', error);
            } finally {
                btn.innerHTML = originalText;
                btn.disabled = false;
            }
        }

        async function loadCombinedCharts() {
            const btn = event.target;
            const originalText = btn.innerHTML;
            
            btn.innerHTML = '<span class="loading"></span> Loading...';
            btn.disabled = true;
            
            try {
                if (window.analyticsCharts) {
                    await window.analyticsCharts.renderCombinedAnalytics();
                }
            } catch (error) {
                console.error('Failed to load combined charts:', error);
            } finally {
                btn.innerHTML = originalText;
                btn.disabled = false;
            }
        }

        async function loadFitnessEntries() {
            const btn = event.target;
            const responseEl = document.getElementById('fitness-entries-response');
            
            btn.innerHTML = '<span class="loading"></span> Loading...';
            btn.disabled = true;
            
            responseEl.classList.remove('hidden');
            
            responseEl.textContent = await apiRequest('/api/entries/fitness',);
            
            btn.innerHTML = 'üèÉ Load Fitness Entries';
            btn.disabled = false;
        }

        async function loadCricketCoaching() {
            const btn = event.target;
            const responseEl = document.getElementById('cricket-coaching-response');
            
            btn.innerHTML = '<span class="loading"></span> Loading...';
            btn.disabled = true;
            
            responseEl.classList.remove('hidden');
            responseEl.textContent = await apiRequest('/api/entries/cricket/coaching');
            
            btn.innerHTML = 'üèè Load Coaching Sessions';
            btn.disabled = false;
        }

        // Tab switching function
        function showTab(tabName) {
            // Remove active class from all tabs
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Hide all tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.add('hidden');
            });
            
            // Show selected tab and content
            const activeTab = document.querySelector(`[data-tab="${tabName}"]`);
            const activeContent = document.getElementById(`${tabName}-tab`);
            
            if (activeTab && activeContent) {
                activeTab.classList.add('active');
                activeContent.classList.remove('hidden');
                
                // Auto-load charts when analytics tab is opened
                if (tabName === 'analytics') {
                    setTimeout(() => {
                        if (window.analyticsCharts && !activeContent.querySelector('.chart-container')) {
                            loadFitnessChartsAuto();
                        }
                    }, 300);
                }
            }
        }
        
        // Auto-load fitness charts when analytics tab opens
        async function loadFitnessChartsAuto() {
            try {
                if (window.analyticsCharts) {
                    await window.analyticsCharts.renderFitnessAnalytics();
                }
            } catch (error) {
                console.error('Failed to auto-load fitness charts:', error);
            }
        }

        // Set up record button click handler
        document.addEventListener('DOMContentLoaded', function() {
            const recordBtn = document.getElementById('record-btn');
            recordBtn.addEventListener('click', toggleRecording);

            // Initialize Mobile Dashboard
            if (typeof MobileDashboard !== 'undefined') {
                window.mobileDashboard = new MobileDashboard();
                console.log('‚úÖ MobileDashboard initialized successfully');
            } else {
                console.error('‚ùå MobileDashboard class not found');
            }

            console.log('üèè Cricket Fitness Tracker Enhanced loaded');
            console.log('Mobile-first interface with working voice recording');
        });
    </script>

    <!-- Activity Details Modal -->
    <div id="activityModal" class="modal" style="display: none;">
        <div class="modal-backdrop" onclick="window.mobileDashboard.closeActivityModal()"></div>
        <div class="modal-container">
            <div id="activityModalContent" class="modal-content">
                <!-- Content will be populated by JavaScript -->
            </div>
        </div>
    </div>

</body>
</html> 